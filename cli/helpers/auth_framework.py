"""Auth framework code and script generator.

Provides ``AUTH_FRAMEWORK_CODE`` — pure-stdlib Python source that handles
token caching, expiry checking, credential prompting, Restish adapter mode,
and standalone ``--token`` mode.  The ``generate_auth_script`` function
stitches the LLM-generated acquire/refresh functions with the framework
into a single self-contained script.
"""

from __future__ import annotations

import textwrap

# ---------------------------------------------------------------------------
# Framework source code — pasted verbatim into generated auth scripts.
#
# Constraints:
#   • Pure Python stdlib (no spectral imports)
#   • Handles two entry points:
#       - default: print a valid token to stdout
#       - --restish: Restish external-tool JSON stdin/stdout contract
#   • Token caching in ~/.cache/spectral/<api_name>/token.json
#   • JWT exp claim detection + TTL fallback
#   • Interactive credential prompting via /dev/tty
# ---------------------------------------------------------------------------

AUTH_FRAMEWORK_CODE = textwrap.dedent('''\
    # ── Auth framework (generated by Spectral) ─────────────────────────────
    import base64
    import getpass
    import json
    import os
    import sys
    import time
    from pathlib import Path


    class TokenCache:
        """Read/write/clear cached tokens on disk."""

        def __init__(self, api_name: str) -> None:
            self._path = (
                Path.home() / ".cache" / "spectral" / api_name / "token.json"
            )

        def read(self) -> dict | None:
            """Return cached token dict, or None if missing/corrupt."""
            try:
                return json.loads(self._path.read_text())
            except (FileNotFoundError, json.JSONDecodeError, OSError):
                return None

        def write(self, data: dict) -> None:
            """Persist *data* as the cached token."""
            self._path.parent.mkdir(parents=True, exist_ok=True)
            self._path.write_text(json.dumps(data))

        def clear(self) -> None:
            """Remove the cached token file."""
            try:
                self._path.unlink()
            except FileNotFoundError:
                pass


    def _decode_jwt_payload(token: str) -> dict | None:
        """Decode the payload of a JWT without verification."""
        parts = token.split(".")
        if len(parts) != 3:
            return None
        try:
            payload = parts[1]
            # Add padding
            payload += "=" * (-len(payload) % 4)
            return json.loads(base64.urlsafe_b64decode(payload))
        except Exception:
            return None


    def is_token_expired(cached: dict) -> bool:
        """Check whether a cached token dict is expired.

        Checks JWT ``exp`` claim first, then falls back to a TTL based on
        ``expires_in`` (or 1 h default) measured from ``acquired_at``.
        """
        token_value = cached.get("token", "")
        jwt_payload = _decode_jwt_payload(token_value) if token_value else None

        if jwt_payload and "exp" in jwt_payload:
            return time.time() >= jwt_payload["exp"]

        acquired_at = cached.get("acquired_at")
        if acquired_at is None:
            return True

        ttl = int(cached.get("expires_in", 3600))
        return time.time() >= acquired_at + ttl


    def prompt_credentials(
        credential_fields: dict[str, str],
    ) -> dict[str, str]:
        """Prompt the user for each credential field via /dev/tty.

        *credential_fields* maps field names to human descriptions.
        Fields whose name contains "password" or "secret" use masked input.
        """
        tty_out = open("/dev/tty", "w")
        tty_in = open("/dev/tty", "r")
        creds: dict[str, str] = {}
        for field, description in credential_fields.items():
            is_secret = any(
                kw in field.lower() for kw in ("password", "secret", "pin")
            )
            if is_secret:
                tty_out.write(f"{description}: ")
                tty_out.flush()
                creds[field] = getpass.getpass(prompt="", stream=tty_out)
            else:
                tty_out.write(f"{description}: ")
                tty_out.flush()
                creds[field] = tty_in.readline().strip()
        tty_out.close()
        tty_in.close()
        return creds


    def get_token(
        cache: TokenCache,
        credential_fields: dict[str, str],
    ) -> str:
        """Return a valid token, refreshing or re-acquiring as needed."""
        cached = cache.read()

        # 1. Valid cached token
        if cached and not is_token_expired(cached):
            return cached["token"]

        # 2. Try refresh if we have a refresh token and a refresh function
        _refresh_fn = globals().get("refresh_token")
        if cached and cached.get("refresh_token") and callable(_refresh_fn):
            try:
                result = _refresh_fn(cached["refresh_token"])
                result["acquired_at"] = time.time()
                if "refresh_token" not in result and cached.get("refresh_token"):
                    result["refresh_token"] = cached["refresh_token"]
                cache.write(result)
                return result["token"]
            except Exception:
                pass

        # 3. Acquire new token
        creds = prompt_credentials(credential_fields)
        result = acquire_token(creds)  # noqa: F821
        result["acquired_at"] = time.time()
        cache.write(result)
        return result["token"]


    def restish_mode(token_header: str, token_prefix: str) -> None:
        """Restish external-tool mode: read JSON stdin, inject auth, write stdout."""
        request = json.loads(sys.stdin.read())
        cache = TokenCache(_API_NAME)  # noqa: F821
        token = get_token(cache, _CREDENTIAL_FIELDS)  # noqa: F821
        value = f"{token_prefix} {token}".strip() if token_prefix else token
        request.setdefault("headers", {})
        request["headers"][token_header] = [value]
        sys.stdout.write(json.dumps(request))


    def token_mode() -> None:
        """Default mode: print a valid token to stdout."""
        cache = TokenCache(_API_NAME)  # noqa: F821
        token = get_token(cache, _CREDENTIAL_FIELDS)  # noqa: F821
        sys.stdout.write(token)


    def main(
        api_name: str,
        credential_fields: dict[str, str],
        token_header: str = "Authorization",
        token_prefix: str = "Bearer",
    ) -> None:
        """Entry point: dispatch to restish_mode or token_mode."""
        # Expose config as module globals so helpers can access them
        global _API_NAME, _CREDENTIAL_FIELDS
        _API_NAME = api_name
        _CREDENTIAL_FIELDS = credential_fields

        if "--restish" in sys.argv:
            restish_mode(token_header, token_prefix)
        else:
            token_mode()
''')


def generate_auth_script(
    *,
    acquire_source: str,
    api_name: str,
    credential_fields: dict[str, str],
    token_header: str = "Authorization",
    token_prefix: str = "Bearer",
) -> str:
    """Stitch LLM-generated acquire/refresh functions with the framework.

    Returns a complete, self-contained Python script as a string.
    """
    # Section 1: Shebang + stdlib imports used by the acquire function
    header = textwrap.dedent("""\
        #!/usr/bin/env python3
        \"\"\"Auth helper for {api_name}.

        Usage:
            python3 {script_name}            Print a valid token to stdout
            python3 {script_name} --restish   Restish external-tool mode

        Generated by Spectral.
        \"\"\"

    """).format(
        api_name=api_name,
        script_name=f"{_safe_filename(api_name)}-auth.py",
    )

    # Section 2: LLM-generated acquire/refresh functions
    acquire_section = (
        "# ── Token acquisition (LLM-generated) "
        "──────────────────────────────────\n\n"
        + acquire_source.rstrip()
        + "\n\n"
    )

    # Section 3: Framework code
    framework_section = AUTH_FRAMEWORK_CODE

    # Section 4: Entry point with API-specific parameters
    creds_repr = repr(credential_fields)
    entry_point = textwrap.dedent(f"""\

        # ── Entry point ─────────────────────────────────────────────────────────
        if __name__ == "__main__":
            main(
                api_name={api_name!r},
                credential_fields={creds_repr},
                token_header={token_header!r},
                token_prefix={token_prefix!r},
            )
    """)

    return header + acquire_section + framework_section + entry_point


def _safe_filename(name: str) -> str:
    """Convert an API name to a safe filename fragment."""
    import re

    return re.sub(r"[^a-zA-Z0-9_-]", "-", name).strip("-").lower()
